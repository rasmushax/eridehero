/**
 * ERideHero Tooltip System
 *
 * Lightweight, accessible tooltips with smart positioning.
 *
 * Usage (declarative):
 *   <button data-tooltip="Helpful text here">Hover me</button>
 *   <button data-tooltip="Top tooltip" data-tooltip-position="top">Top</button>
 *
 * Usage (programmatic):
 *   import { createTooltip, destroyTooltip } from './tooltip.js';
 *   createTooltip(element, { content: 'Hello', position: 'top' });
 *
 * Positions: top (default), bottom, left, right
 * Auto-flips when near viewport edges.
 */

// Configuration
const CONFIG = {
    showDelay: 200,        // Delay before showing (ms)
    hideDelay: 100,        // Delay before hiding (ms)
    offset: 8,             // Distance from trigger element (px)
    viewportPadding: 12,   // Min distance from viewport edge (px)
    animationDuration: 150 // CSS transition duration (ms)
};

// Tooltip container (created once, reused)
let tooltipEl = null;
let currentTrigger = null;
let showTimeout = null;
let hideTimeout = null;
let justTouched = false; // Prevent click firing after touch

/**
 * Initialize the tooltip system
 */
function init() {
    // Create tooltip element
    if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.className = 'tooltip';
        tooltipEl.setAttribute('role', 'tooltip');
        tooltipEl.setAttribute('aria-hidden', 'true');
        tooltipEl.innerHTML = '<div class="tooltip-content"></div><div class="tooltip-arrow"></div>';
        document.body.appendChild(tooltipEl);
    }

    // Event delegation for declarative tooltips
    document.addEventListener('mouseenter', handleMouseEnter, true);
    document.addEventListener('mouseleave', handleMouseLeave, true);
    document.addEventListener('focusin', handleFocusIn, true);
    document.addEventListener('focusout', handleFocusOut, true);

    // Click support for click-triggered tooltips
    document.addEventListener('click', handleClick, true);

    // Touch support
    document.addEventListener('touchstart', handleTouchStart, { passive: true });

    // Hide on scroll/resize
    window.addEventListener('scroll', hideTooltip, { passive: true, capture: true });
    window.addEventListener('resize', hideTooltip, { passive: true });

    // Hide on escape
    document.addEventListener('keydown', handleKeyDown);
}

/**
 * Check if trigger uses click mode
 */
function isClickTrigger(trigger) {
    return trigger.getAttribute('data-tooltip-trigger') === 'click' ||
           trigger.closest('.info-trigger') !== null;
}

/**
 * Event Handlers
 */
function handleMouseEnter(e) {
    if (!e.target.closest) return;
    const trigger = e.target.closest('[data-tooltip]');
    if (trigger && !isClickTrigger(trigger)) {
        scheduleShow(trigger);
    }
}

function handleMouseLeave(e) {
    if (!e.target.closest) return;
    const trigger = e.target.closest('[data-tooltip]');
    if (trigger && !isClickTrigger(trigger)) {
        scheduleHide();
    }
}

function handleFocusIn(e) {
    if (!e.target.closest) return;
    const trigger = e.target.closest('[data-tooltip]');
    if (trigger && !isClickTrigger(trigger)) {
        scheduleShow(trigger);
    }
}

function handleFocusOut(e) {
    if (!e.target.closest) return;
    const trigger = e.target.closest('[data-tooltip]');
    if (trigger && !isClickTrigger(trigger)) {
        scheduleHide();
    }
}

function handleClick(e) {
    // Skip if this click was generated by a touch event (already handled)
    if (justTouched) return;

    if (!e.target.closest) return;
    const trigger = e.target.closest('[data-tooltip]');

    if (trigger && isClickTrigger(trigger)) {
        e.preventDefault();
        e.stopPropagation();

        // Toggle tooltip
        if (currentTrigger === trigger && tooltipEl.classList.contains('is-visible')) {
            hideTooltip();
        } else {
            showTooltip(trigger);
        }
    } else if (tooltipEl && tooltipEl.classList.contains('is-visible') && isClickTrigger(currentTrigger)) {
        // Clicked elsewhere while click-tooltip is open, hide it
        hideTooltip();
    }
}

function handleTouchStart(e) {
    if (!e.target.closest) return;
    const trigger = e.target.closest('[data-tooltip]');

    // Set flag to prevent click from firing after touch
    justTouched = true;
    setTimeout(() => {
        justTouched = false;
    }, 300);

    if (trigger) {
        // If tooltip is showing for this trigger, hide it
        if (currentTrigger === trigger && tooltipEl.classList.contains('is-visible')) {
            hideTooltip();
        } else {
            // Show tooltip for touched element
            showTooltip(trigger);
        }
    } else if (tooltipEl && tooltipEl.classList.contains('is-visible')) {
        // Touched elsewhere, hide tooltip
        hideTooltip();
    }
}

function handleKeyDown(e) {
    if (e.key === 'Escape' && tooltipEl.classList.contains('is-visible')) {
        hideTooltip();
    }
}

/**
 * Show/Hide Logic
 */
function scheduleShow(trigger) {
    clearTimeout(hideTimeout);
    clearTimeout(showTimeout);

    showTimeout = setTimeout(() => {
        showTooltip(trigger);
    }, CONFIG.showDelay);
}

function scheduleHide() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);

    hideTimeout = setTimeout(() => {
        hideTooltip();
    }, CONFIG.hideDelay);
}

function showTooltip(trigger) {
    if (!tooltipEl || !trigger) return;

    const content = trigger.getAttribute('data-tooltip');
    if (!content) return;

    currentTrigger = trigger;

    // Set content
    const contentEl = tooltipEl.querySelector('.tooltip-content');
    contentEl.textContent = content;

    // Set up accessibility
    const tooltipId = 'tooltip-' + Math.random().toString(36).substr(2, 9);
    tooltipEl.id = tooltipId;
    trigger.setAttribute('aria-describedby', tooltipId);

    // Get preferred position
    const preferredPosition = trigger.getAttribute('data-tooltip-position') || 'top';

    // Show (invisible) to measure
    tooltipEl.style.visibility = 'hidden';
    tooltipEl.classList.add('is-visible');
    tooltipEl.setAttribute('aria-hidden', 'false');

    // Calculate position
    const position = calculatePosition(trigger, preferredPosition);

    // Apply position
    tooltipEl.style.left = `${position.x}px`;
    tooltipEl.style.top = `${position.y}px`;
    tooltipEl.setAttribute('data-position', position.placement);

    // Apply arrow offset (always calculated now)
    const arrowEl = tooltipEl.querySelector('.tooltip-arrow');
    if (arrowEl) {
        if (position.arrowOffset) {
            arrowEl.style.setProperty('--arrow-offset', `${position.arrowOffset}px`);
        } else {
            arrowEl.style.removeProperty('--arrow-offset');
        }
    }

    // Make visible
    tooltipEl.style.visibility = '';
}

function hideTooltip() {
    if (!tooltipEl) return;

    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);

    tooltipEl.classList.remove('is-visible');
    tooltipEl.setAttribute('aria-hidden', 'true');

    if (currentTrigger) {
        currentTrigger.removeAttribute('aria-describedby');
        currentTrigger = null;
    }
}

/**
 * Smart Positioning
 * Calculates optimal position, auto-flipping if needed
 */
function calculatePosition(trigger, preferredPosition) {
    const triggerRect = trigger.getBoundingClientRect();
    const tooltipRect = tooltipEl.getBoundingClientRect();
    const scrollX = window.scrollX;
    const scrollY = window.scrollY;

    const viewport = {
        width: window.innerWidth,
        height: window.innerHeight
    };

    // Calculate all possible positions
    const positions = {
        top: {
            x: triggerRect.left + (triggerRect.width - tooltipRect.width) / 2,
            y: triggerRect.top - tooltipRect.height - CONFIG.offset
        },
        bottom: {
            x: triggerRect.left + (triggerRect.width - tooltipRect.width) / 2,
            y: triggerRect.bottom + CONFIG.offset
        },
        left: {
            x: triggerRect.left - tooltipRect.width - CONFIG.offset,
            y: triggerRect.top + (triggerRect.height - tooltipRect.height) / 2
        },
        right: {
            x: triggerRect.right + CONFIG.offset,
            y: triggerRect.top + (triggerRect.height - tooltipRect.height) / 2
        }
    };

    // Check if position fits in viewport
    function fitsInViewport(pos, placement) {
        const x = pos.x;
        const y = pos.y;

        if (placement === 'top' || placement === 'bottom') {
            return y >= CONFIG.viewportPadding &&
                   y + tooltipRect.height <= viewport.height - CONFIG.viewportPadding &&
                   x >= CONFIG.viewportPadding &&
                   x + tooltipRect.width <= viewport.width - CONFIG.viewportPadding;
        } else {
            return x >= CONFIG.viewportPadding &&
                   x + tooltipRect.width <= viewport.width - CONFIG.viewportPadding &&
                   y >= CONFIG.viewportPadding &&
                   y + tooltipRect.height <= viewport.height - CONFIG.viewportPadding;
        }
    }

    // Determine which placement to use
    let placement = preferredPosition;
    let finalX, finalY;

    // Try preferred position first
    if (fitsInViewport(positions[preferredPosition], preferredPosition)) {
        finalX = positions[preferredPosition].x;
        finalY = positions[preferredPosition].y;
    } else {
        // Try opposite position
        const opposites = { top: 'bottom', bottom: 'top', left: 'right', right: 'left' };
        const opposite = opposites[preferredPosition];

        if (fitsInViewport(positions[opposite], opposite)) {
            placement = opposite;
            finalX = positions[opposite].x;
            finalY = positions[opposite].y;
        } else {
            // Try other positions
            const fallbacks = preferredPosition === 'top' || preferredPosition === 'bottom'
                ? ['left', 'right']
                : ['top', 'bottom'];

            let found = false;
            for (const pos of fallbacks) {
                if (fitsInViewport(positions[pos], pos)) {
                    placement = pos;
                    finalX = positions[pos].x;
                    finalY = positions[pos].y;
                    found = true;
                    break;
                }
            }

            // Fallback: constrain to viewport
            if (!found) {
                finalX = positions[preferredPosition].x;
                finalY = positions[preferredPosition].y;

                // Constrain horizontally
                finalX = Math.max(CONFIG.viewportPadding, Math.min(finalX, viewport.width - tooltipRect.width - CONFIG.viewportPadding));

                // Constrain vertically
                finalY = Math.max(CONFIG.viewportPadding, Math.min(finalY, viewport.height - tooltipRect.height - CONFIG.viewportPadding));
            }
        }
    }

    // Always calculate arrow offset to ensure it points at trigger center
    let arrowOffset = 0;
    if (placement === 'top' || placement === 'bottom') {
        const triggerCenterX = triggerRect.left + triggerRect.width / 2;
        const tooltipCenterX = finalX + tooltipRect.width / 2;
        arrowOffset = triggerCenterX - tooltipCenterX;
    } else {
        const triggerCenterY = triggerRect.top + triggerRect.height / 2;
        const tooltipCenterY = finalY + tooltipRect.height / 2;
        arrowOffset = triggerCenterY - tooltipCenterY;
    }

    // Only apply offset if it's significant (more than 1px)
    const significantOffset = Math.abs(arrowOffset) > 1 ? arrowOffset : 0;

    return {
        x: finalX + scrollX,
        y: finalY + scrollY,
        placement: placement,
        arrowOffset: significantOffset
    };
}

/**
 * Programmatic API
 */
export function createTooltip(element, options = {}) {
    const content = options.content || '';
    const position = options.position || 'top';

    element.setAttribute('data-tooltip', content);
    element.setAttribute('data-tooltip-position', position);

    return {
        update: (newContent) => element.setAttribute('data-tooltip', newContent),
        destroy: () => destroyTooltip(element)
    };
}

export function destroyTooltip(element) {
    element.removeAttribute('data-tooltip');
    element.removeAttribute('data-tooltip-position');
    element.removeAttribute('aria-describedby');

    if (currentTrigger === element) {
        hideTooltip();
    }
}

export function showTooltipFor(element) {
    if (element.hasAttribute('data-tooltip')) {
        showTooltip(element);
    }
}

export function hideAllTooltips() {
    hideTooltip();
}

// Auto-initialize
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
} else {
    init();
}

export default {
    create: createTooltip,
    destroy: destroyTooltip,
    show: showTooltipFor,
    hideAll: hideAllTooltips
};
